<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Andey Robins</title><link>https://blog.andeyrobins.org/post/</link><description>Recent content in Posts on Andey Robins</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 19 Jul 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.andeyrobins.org/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Power based Side Channels with Homogenous States</title><link>https://blog.andeyrobins.org/p/homogenous-states/</link><pubDate>Wed, 19 Jul 2023 00:00:00 +0000</pubDate><guid>https://blog.andeyrobins.org/p/homogenous-states/</guid><description>&lt;img src="https://blog.andeyrobins.org/p/homogenous-states/cover.jpg" alt="Featured image of post Power based Side Channels with Homogenous States" />&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>So this paper was my first submission to a journal, and that experience was a whole interesting one in its own regard, but that&amp;rsquo;s a matter for another day. This paper primarily concerns itself with demonstrating the following: program control flow on low power devices is recoverable via simple power analysis. There had been suggestions in the literature that this was the case, but to the knowledge and research of me and the team I worked with, there had been no verification of this assumption in the physical world.&lt;/p>
&lt;p>We began with a separate paper (Transition Recovery Attack on Embedded State Machines Using Power Analysis) which provided the most foundational proof of concept we could come up with. Using two distinct operations, and a state machine with only two states, could we apply simple analysis with machine learning to classify the state transitions that occured. The answer was a clear yes, and after applying additional models to the same dataset after submitting that paper, we were convinced that there were far less strinct bounds on assumptions than might be assumed.&lt;/p>
&lt;p>This naturally fed into the question: must different work be performed in the states of a state machine to identify their difference, or is the power utilized during the transition code itself (in other words the control flow code) sufficient to recover the transitions with simple power analysis. More advanced power analysis techniques were of course possible, but for reasons I&amp;rsquo;ll discuss in a bit, we wanted to avoid these more computationally difficult tasks.&lt;/p>
&lt;h2 id="spa-vs-pa">SPA vs *PA&lt;/h2>
&lt;p>There are a lot of different methods of power analysis discussed in the field of side-channel attacks. Differential and simple are probably the most well known, but others exist (e.g. dynamic, complex, etc.). Additionally, applying deep learning to the task is something quickly picking up in the literature, and it has shown to be quite useful.&lt;/p>
&lt;p>However, the computational complexity of applying deep learning models to ML data is something we see as exponentially higher than applying simple power analysis. Since it&amp;rsquo;s the current state-of-the-art, many projects use deep learning to great affect without explicitly discussing the potential for using simple power analysis techniques instead. We had the ability to generate massive amounts of data, so deep learning would have been a strong option. We even had access to large amounts of computational power, so resources were not the concern. Time and the capabilities of the system were our largest issue.&lt;/p>
&lt;p>More complex control flow may one day necessitate using deep learning to be able to recover it, I&amp;rsquo;ll certainly admit to that, but, at the moment, simple power analysis is perfectly capable of performing the attacks described in both of these works. I think there&amp;rsquo;s value in using a simpler model simply by the nature of it being more simplistic. It&amp;rsquo;s easier for other researchers to build upon and utilize clear findings than it is to build upon and extend a complex deep learning system. As AI and ML become larger and larger, explainability seems to be taking a back seat in favor of powerful predictive power. In many applications, this is perfectly fine, but in low-power or embedded security, I would rather have the simpler and more explainable model when they are capable of strong results.&lt;/p>
&lt;h2 id="attack-vector-realization">Attack Vector Realization&lt;/h2>
&lt;p>At this point, I&amp;rsquo;m beginning to wonder just how applicable this attack would be as an attack vector in the &amp;ldquo;real&amp;rdquo; world. For instance, being able to identify and recover transition information for the state machine running your smart lock or a streetlight could be sensitive information, but is it actionable information? Possibly.&lt;/p>
&lt;p>This information in and of itself probably isn&amp;rsquo;t going to be hugely detrimental, but as the trigger system for another attack, it does seem to be worth protecting. When paired with a properly instrumented injection attack, it could potentially allow an attacker to force the state machine through a specific execution pipeline.&lt;/p>
&lt;p>Now this attack would be far more dangerous. If your smart lock can be diverted to the &amp;ldquo;open&amp;rdquo; state when you enter the wrong code or a streetlight can be forced into the &amp;ldquo;red&amp;rdquo; state when it should be green, an attacker could cause real damage. This doesn&amp;rsquo;t even address the topic of internet connected medical devices which we use as a potential motivation in the first paper on this topic.&lt;/p>
&lt;p>The problem is, we haven&amp;rsquo;t seen this type of an attack yet. While we&amp;rsquo;re able to fully recover state transition information, it&amp;rsquo;s all in the aftermath of execution. An online algorithm, which can take live signals and flag &lt;em>when&lt;/em> a transition is occuring would be hugely valuable from a security research perspective.&lt;/p>
&lt;h2 id="future-directions">Future Directions&lt;/h2>
&lt;p>This online algorithm is what I see as the best future direction. Some of my co-authors have other directions, which are discussed more in the paper, and which have been raised as valuable future research directions by others in the field. However, in my view, they are foundationally the same question just being explored to find the bounds of this type of attack. This work is undoubtedly important, but I find myself first wishing for a longitudinal demonstration of this type of attack before expanding to determine the full potential attack surface. If no possible attacks are able to use this information, what should designers do to protect the information? Is the answer nothing? That would be a bad one in my opinion.&lt;/p>
&lt;p>This difference in future direction seems very natural though. We initially collaborate to prove something possible and then we all have slightly different ideas to explore within that space. I have no doubt that I&amp;rsquo;ll benefit from their research and I hope they will benefit from mine.&lt;/p>
&lt;h2 id="final-thoughts">Final Thoughts&lt;/h2>
&lt;p>Overall, I believe this paper to be my best to date (not hard when it&amp;rsquo;s the fourth to date as well). Personally I loved the sections on how we generated the data, because there were some considerations about efficiently instrumenting the ChipWhisperer Nano for large scale data collection. The python interface leaves some things to be desired, and we built around it as best as possible.&lt;/p>
&lt;p>Please support the official publication. It&amp;rsquo;s open access! See the link below for the full article.&lt;/p>
&lt;blockquote>
&lt;p>Photo by &lt;a class="link" href="https://unsplash.com/@jsshotz?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText" target="_blank" rel="noopener"
>Jorge Salvador&lt;/a> on &lt;a class="link" href="https://unsplash.com/photos/c6hEUfgiwnw?utm_source=unsplash&amp;amp;utm_medium=referral&amp;amp;utm_content=creditCopyText" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/p>
&lt;/blockquote></description></item></channel></rss>